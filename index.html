import asyncio
import logging
import os
import json
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.utils.keyboard import InlineKeyboardBuilder, ReplyKeyboardBuilder
from aiocryptopay import AioCryptoPay
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import BotCommand, WebAppInfo, KeyboardButton, ContentType

# --- –ù–ê–°–¢–†–û–ô–ö–ò ---
BOT_TOKEN = "8508733334:AAG2B0F8KDlI853OV7D-nQvaJjMSJn_gAaI"
CRYPTO_TOKEN = "521815:AAlbgxr1GMcNTAJcgPDpl8VUjZ0uCwKXkNS"
ADMIN_ID = 7248279200 
SUPPORT_USERNAME = "Dag_stars_helper"
BASE_URL = "https://exstazy57.github.io/index.html" 

DATA_FILE = "users_data.json"
USERS_FILE = "users_db.txt"
PRICE_PER_STAR_RUB = 1.4  
USD_RATE = 95.0            

logging.basicConfig(level=logging.INFO)
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()
crypto = AioCryptoPay(token=CRYPTO_TOKEN)

# --- –°–ò–°–¢–ï–ú–ê –î–ê–ù–ù–´–• ---
def load_data():
    if not os.path.exists(DATA_FILE): return {}
    try:
        with open(DATA_FILE, "r", encoding="utf-8") as f: return json.load(f)
    except: return {}

def save_data(data):
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

def update_balance(user_id, amount):
    data = load_data()
    uid = str(user_id)
    if uid not in data:
        data[uid] = {"balance": 0}
    data[uid]["balance"] += int(amount)
    save_data(data)
    return data[uid]["balance"]

def get_balance(user_id):
    data = load_data()
    return data.get(str(user_id), {}).get("balance", 0)

# --- –ö–õ–ê–í–ò–ê–¢–£–†–ê (–ò–ì–†–´ –í–°–ï–ì–î–ê –í–ò–î–ù–´) ---
def get_main_menu():
    builder = ReplyKeyboardBuilder()
    builder.row(KeyboardButton(text="üíé –ö–£–ü–ò–¢–¨ –ó–í–ï–ó–î–´"), KeyboardButton(text="üí∞ –ú–û–ô –ë–ê–õ–ê–ù–°"))
    builder.row(
        KeyboardButton(text="üê¶ DAG BIRD", web_app=WebAppInfo(url=f"{BASE_URL}/index.html?v=8")),
        KeyboardButton(text="üí£ –ú–ò–ù–´", web_app=WebAppInfo(url=f"{BASE_URL}/mines.html?v=8"))
    )
    return builder.as_markup(resize_keyboard=True)

# --- –•–ï–ù–î–õ–ï–†–´ ---

@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    update_balance(message.from_user.id, 0)
    await message.answer(
        "üåü **–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ DAG Stars!**\n\n"
        "–í—ã–±–∏—Ä–∞–π—Ç–µ –∏–≥—Ä—É –∏–ª–∏ –ø–æ–ø–æ–ª–Ω—è–π—Ç–µ –±–∞–ª–∞–Ω—Å –¥–ª—è —Å—Ç–∞–≤–æ–∫.",
        reply_markup=get_main_menu()
    )

@dp.message(F.text == "üí∞ –ú–û–ô –ë–ê–õ–ê–ù–°")
async def show_balance(message: types.Message):
    bal = get_balance(message.from_user.id)
    await message.answer(f"üí∞ –¢–≤–æ–π –±–∞–ª–∞–Ω—Å: **{bal} ‚≠ê**")

@dp.message(F.text == "üíé –ö–£–ü–ò–¢–¨ –ó–í–ï–ó–î–´")
async def shop_menu(message: types.Message):
    builder = InlineKeyboardBuilder()
    for opt in [50, 100, 250, 500]:
        price = round(opt * PRICE_PER_STAR_RUB, 1)
        builder.row(types.InlineKeyboardButton(text=f"{opt} ‚≠ê ‚Äî {price}‚ÇΩ", callback_data=f"buy_{opt}_{price}"))
    await message.answer("üõí –í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç –∑–≤–µ–∑–¥:", reply_markup=builder.as_markup())

# --- –ü–†–û–í–ï–†–ö–ê –ë–ê–õ–ê–ù–°–ê –ü–†–ò –ó–ê–í–ï–†–®–ï–ù–ò–ò –ò–ì–†–´ ---
@dp.message(F.content_type == ContentType.WEB_APP_DATA)
async def handle_game_end(message: types.Message):
    try:
        res = json.loads(message.web_app_data.data)
        bet = int(res.get("bet", 0))
        action = res.get("action")
        
        current_bal = get_balance(message.from_user.id)

        # –°–ê–ú–ê–Ø –í–ê–ñ–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê
        if current_bal < bet or current_bal <= 0:
            return await message.answer(
                f"‚ùå **–ò–≥—Ä–∞ –Ω–µ –∑–∞—Å—á–∏—Ç–∞–Ω–∞!**\n\n"
                f"–¢–≤–æ—è —Å—Ç–∞–≤–∫–∞: {bet} ‚≠ê\n"
                f"–¢–≤–æ–π –±–∞–ª–∞–Ω—Å: {current_bal} ‚≠ê\n"
                f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –ø–æ–ø–æ–ª–Ω–∏ –±–∞–ª–∞–Ω—Å."
            )

        if action == "win":
            win = int(res.get("amount", 0))
            new_bal = update_balance(message.from_user.id, win - bet)
            await message.answer(f"üéØ **–ü–æ–±–µ–¥–∞!**\n–ó–∞—á–∏—Å–ª–µ–Ω–æ: {win} ‚≠ê\n–ë–∞–ª–∞–Ω—Å: {new_bal} ‚≠ê")
        elif action == "loss":
            new_bal = update_balance(message.from_user.id, -bet)
            await message.answer(f"üí• **–ú–∏–Ω–∞!**\n–°–ø–∏—Å–∞–Ω–æ: {bet} ‚≠ê\n–ë–∞–ª–∞–Ω—Å: {new_bal} ‚≠ê")
            
    except Exception as e:
        logging.error(f"Error: {e}")

# (–û—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –æ–ø–ª–∞—Ç—ã –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
@dp.callback_query(F.data.startswith("buy_"))
async def create_pay(callback: types.CallbackQuery):
    _, amt, price = callback.data.split("_")
    price_usd = round(float(price) / USD_RATE, 2)
    inv = await crypto.create_invoice(asset='USDT', amount=price_usd)
    kb = InlineKeyboardBuilder()
    kb.row(types.InlineKeyboardButton(text="üí∏ –û–ø–ª–∞—Ç–∏—Ç—å", url=inv.bot_invoice_url))
    kb.row(types.InlineKeyboardButton(text="‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å", callback_data=f"check_{inv.invoice_id}_{amt}"))
    await callback.message.edit_text(f"üíé –ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ: {amt} ‚≠ê\n–°—É–º–º–∞: {price_usd} USDT", reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("check_"))
async def check_pay(callback: types.CallbackQuery):
    _, inv_id, amt = callback.data.split("_")
    invs = await crypto.get_invoices(invoice_ids=inv_id)
    status = invs.status if not isinstance(invs, list) else invs[0].status
    if status == 'paid':
        update_balance(callback.from_user.id, amt)
        await callback.message.edit_text(f"‚úÖ –û–ø–ª–∞—á–µ–Ω–æ! –ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω –Ω–∞ {amt} ‚≠ê")
    else:
        await callback.answer("‚è≥ –û–ø–ª–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
