<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PLINKO SHAKE & SOUND</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap" rel="stylesheet">
    <style>
        :root { --neon: #00f2ff; --bg: #05070a; }
        body { margin: 0; background: var(--bg); font-family: 'Orbitron'; color: white; overflow: hidden; touch-action: none; }
        canvas { display: block; }
        
        #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        .top-bar { padding: 10px; pointer-events: auto; }
        .badge { background: rgba(0,0,0,0.8); border: 1px solid var(--neon); padding: 8px 15px; border-radius: 10px; color: var(--neon); font-size: 16px; display: inline-block; box-shadow: 0 0 10px rgba(0,242,255,0.2); }

        /* Компактная панель, не закрывающая слоты */
        #controls { 
            background: rgba(20, 25, 35, 0.9); 
            padding: 15px; 
            pointer-events: auto; 
            border-top: 1px solid #333;
            backdrop-filter: blur(5px);
        }
        
        .risk-bar { display: flex; gap: 5px; margin-bottom: 10px; }
        .risk-btn { flex: 1; padding: 8px; border-radius: 6px; border: 1px solid #444; background: #111; color: #666; font-family: 'Orbitron'; font-size: 10px; cursor: pointer; }
        .risk-btn.active { border-color: var(--neon); color: var(--neon); background: rgba(0,242,255,0.1); }

        .bet-row { display: flex; gap: 10px; margin-bottom: 10px; }
        input { flex: 1; background: #000; border: 1px solid #333; color: white; text-align: center; border-radius: 8px; font-family: 'Orbitron'; font-size: 16px; outline: none; }
        
        #btn-play { flex: 2; padding: 12px; border-radius: 8px; border: none; font-family: 'Orbitron'; font-weight: 900; background: linear-gradient(180deg, #00f2ff, #0077ff); color: #000; cursor: pointer; text-transform: uppercase; }
        
        .exit-link { display: block; margin-top: 8px; color: #444; font-size: 9px; text-decoration: none; text-align: center; }
    </style>
</head>
<body>

<canvas id="plinkoCanvas"></canvas>

<div id="ui">
    <div class="top-bar">
        <div class="badge">⭐ <span id="bal-display">0</span></div>
    </div>
    
    <div id="controls">
        <div class="risk-bar">
            <button class="risk-btn" onclick="setRisk('low')" id="risk-low">НИЗКИЙ</button>
            <button class="risk-btn active" onclick="setRisk('med')" id="risk-med">СРЕДНИЙ</button>
            <button class="risk-btn" onclick="setRisk('high')" id="risk-high">ВЫСОКИЙ</button>
        </div>
        <div class="bet-row">
            <input type="number" id="bet-input" value="10" min="10">
            <button id="btn-play" onclick="dropBall()">СТАВКА</button>
        </div>
        <span class="exit-link" onclick="finalizeAndExit()">СОХРАНИТЬ И ВЫЙТИ</span>
    </div>
</div>

<script>
    const tg = window.Telegram.WebApp;
    tg.expand();

    const canvas = document.getElementById('plinkoCanvas');
    const ctx = canvas.getContext('2d');
    const balDisplay = document.getElementById('bal-display');
    
    let balance = parseInt(new URLSearchParams(window.location.search).get('bal')) || 0;
    balDisplay.innerText = balance.toLocaleString();

    let currentRisk = 'med';
    let balls = [];
    let pins = [];
    let particles = [];
    let bucketFlash = [];
    let shakeAmount = 0;

    // ЗВУКОВОЙ ДВИЖОК
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playPop(freq = 150) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.1);
    }

    const config = {
        low: { rows: 8, buckets: [5, 2, 1.2, 1, 0.5, 1, 1.2, 2, 5] },
        med: { rows: 12, buckets: [15, 5, 2, 0.5, 0.2, 0.1, 0.2, 0.5, 2, 5, 15] },
        high: { rows: 14, buckets: [50, 15, 5, 1, 0.2, 0, 0, 0, 0.2, 1, 5, 15, 50] }
    };

    function initPins() {
        pins = [];
        const rows = config[currentRisk].rows;
        const spacing = canvas.width / (rows + 3);
        for (let i = 2; i <= rows + 1; i++) {
            for (let j = 0; j < i; j++) {
                pins.push({ 
                    x: canvas.width/2 - (i-1)*spacing/2 + j*spacing, 
                    y: 80 + (i-2)*spacing*0.9, active: 0 
                });
            }
        }
        bucketFlash = new Array(config[currentRisk].buckets.length).fill(0);
    }

    function createExplosion(x, y, color) {
        for (let i = 0; i < 12; i++) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 40, color: color
            });
        }
    }

    function setRisk(level) {
        if(balls.length > 0) return;
        currentRisk = level;
        document.querySelectorAll('.risk-btn').forEach(b => b.classList.remove('active'));
        document.getElementById('risk-' + level).classList.add('active');
        initPins();
    }

    function dropBall() {
        const bet = parseInt(document.getElementById('bet-input').value);
        if (bet > balance || bet < 1) return;
        balance -= bet;
        balDisplay.innerText = balance.toLocaleString();
        
        // Хаотичный спавн
        balls.push({ 
            x: canvas.width/2 + (Math.random()-0.5)*15, 
            y: 30, 
            vx: (Math.random()-0.5)*3, 
            vy: 0, 
            bet, risk: currentRisk 
        });
        playPop(200);
    }

    function update() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Эффект тряски
        ctx.save();
        if(shakeAmount > 0) {
            ctx.translate((Math.random()-0.5)*shakeAmount, (Math.random()-0.5)*shakeAmount);
            shakeAmount *= 0.9;
        }

        ctx.fillStyle = "#05070a"; ctx.fillRect(0,0,canvas.width,canvas.height);

        pins.forEach(p => {
            ctx.fillStyle = p.active > 0 ? "#00f2ff" : "#1e232b";
            if(p.active > 0) p.active--;
            ctx.beginPath(); ctx.arc(p.x, p.y, 2.5, 0, 7); ctx.fill();
        });

        const conf = config[currentRisk];
        const bW = canvas.width / conf.buckets.length;
        const bY = canvas.height - 180; // Подняли выше, чтобы не закрывало панелью

        conf.buckets.forEach((m, i) => {
            ctx.fillStyle = m >= 1 ? "#00ff44" : "#ff4444";
            ctx.globalAlpha = bucketFlash[i] > 0 ? 0.6 : 0.2;
            if(bucketFlash[i] > 0) bucketFlash[i]--;
            ctx.beginPath(); ctx.roundRect(i * bW + 2, bY, bW - 4, 30, 5); ctx.fill();
            ctx.globalAlpha = 1; ctx.fillStyle = "white"; ctx.font = "bold 9px Orbitron";
            ctx.textAlign = "center"; ctx.fillText(m + "x", i * bW + bW/2, bY + 18);
        });

        for (let i = balls.length - 1; i >= 0; i--) {
            let b = balls[i];
            
            // "Азартная" физика: микро-ветер
            b.vx += (Math.random() - 0.5) * 0.1;
            b.vy += 0.35; b.x += b.vx; b.y += b.vy;

            pins.forEach(p => {
                const d = Math.hypot(b.x-p.x, b.y-p.y);
                if (d < 8) {
                    p.active = 10;
                    playPop(100 + Math.random()*100);
                    const angle = Math.atan2(b.y - p.y, b.x - p.x);
                    b.vx += Math.cos(angle) * 1.2;
                    b.vy *= 0.4; b.y = p.y + 8;
                }
            });

            ctx.fillStyle = "#00f2ff"; ctx.shadowBlur = 10; ctx.shadowColor = "#00f2ff";
            ctx.beginPath(); ctx.arc(b.x, b.y, 5, 0, 7); ctx.fill(); ctx.shadowBlur = 0;

            if (b.y > bY) {
                let idx = Math.floor(b.x / bW);
                const curB = config[b.risk].buckets;
                idx = Math.max(0, Math.min(idx, curB.length - 1));
                const mult = curB[idx];
                
                balance += Math.floor(b.bet * mult);
                balDisplay.innerText = balance.toLocaleString();
                bucketFlash[idx] = 30;
                
                if(mult >= 5) { shakeAmount = 15; createExplosion(b.x, bY, "#ffaa00"); }
                else { createExplosion(b.x, bY, mult >= 1 ? "#00ff00" : "#ff0000"); }
                
                playPop(mult >= 1 ? 400 : 50);
                balls.splice(i, 1);
            }
        }

        particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life--;
            ctx.globalAlpha = p.life / 40; ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, 1.5, 0, 7); ctx.fill();
            if (p.life <= 0) particles.splice(i, 1);
        });

        ctx.restore();
        requestAnimationFrame(update);
    }

    function finalizeAndExit() {
        tg.sendData(JSON.stringify({action: "sync_balance", final_balance: balance}));
    }

    initPins();
    update();
</script>
</body>
</html>
